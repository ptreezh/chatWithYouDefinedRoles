# éšç§ä¿æŠ¤ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **ç³»ç»Ÿ**: Chat4 éšç§ä¿æŠ¤ç³»ç»Ÿ
- **ç‰ˆæœ¬**: v1.0.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-08-20
- **ç›®æ ‡**: è®¾è®¡å…¨é¢çš„éšç§ä¿æŠ¤æ¡†æ¶ï¼Œç¡®ä¿ç”¨æˆ·æ•°æ®å®‰å…¨

---

## ğŸ¯ ç³»ç»Ÿç›®æ ‡

### æ ¸å¿ƒç›®æ ‡
- **æ•°æ®æœ€å°åŒ–**: åªæ”¶é›†å¿…è¦çš„æ•°æ®
- **ç”¨æˆ·æ§åˆ¶**: ç”¨æˆ·å®Œå…¨æ§åˆ¶è‡ªå·±çš„æ•°æ®
- **é€æ˜åº¦**: æ¸…æ™°çš„æ•°æ®ä½¿ç”¨è¯´æ˜
- **å®‰å…¨æ€§**: é˜²æ­¢æ•°æ®æ³„éœ²å’Œæ»¥ç”¨

### éšç§åŸåˆ™
- **åˆæ³•å…¬æ­£**: ç¬¦åˆGDPRç­‰æ³•è§„è¦æ±‚
- **ç›®çš„é™åˆ¶**: æ•°æ®ä½¿ç”¨ä»…é™äºå£°æ˜çš„ç›®çš„
- **æ•°æ®æœ€å°åŒ–**: åªæ”¶é›†å¿…è¦çš„æ•°æ®
- **å‡†ç¡®æ€§**: ç¡®ä¿æ•°æ®å‡†ç¡®å’Œæ›´æ–°
- **å­˜å‚¨é™åˆ¶**: ä¸é•¿æœŸä¿ç•™æ•°æ®
- **å®Œæ•´ä¿å¯†**: ç¡®ä¿æ•°æ®å®‰å…¨
- **é€æ˜åº¦**: å‘ç”¨æˆ·å…¬å¼€æ•°æ®å¤„ç†

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### éšç§ä¿æŠ¤æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    éšç§ä¿æŠ¤ç³»ç»Ÿ                               â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ æ•°æ®æ”¶é›†å±‚   â”‚  â”‚ æ•°æ®å¤„ç†å±‚   â”‚  â”‚ æ•°æ®åº”ç”¨å±‚   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚        â”‚                 â”‚                 â”‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ åŒæ„ç®¡ç†   â”‚    â”‚ åŠ å¯†è„±æ•   â”‚    â”‚ è®¿é—®æ§åˆ¶   â”‚           â”‚
â”‚  â”‚ æ•°æ®æœ€å°åŒ– â”‚    â”‚ åŒ¿ååŒ–     â”‚    â”‚ å®¡è®¡æ—¥å¿—   â”‚           â”‚
â”‚  â”‚ é€æ˜åº¦     â”‚    â”‚ å·®åˆ†éšç§   â”‚    â”‚ ç”¨æˆ·æƒåˆ©   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®¢æˆ·ç«¯                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ æœ¬åœ°åŠ å¯†    â”‚  â”‚ å·®åˆ†éšç§    â”‚  â”‚ è®¿é—®æ§åˆ¶    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼ (åŠ å¯†ä¼ è¾“)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡ç«¯                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ è”é‚¦å­¦ä¹     â”‚  â”‚ å®‰å…¨å­˜å‚¨    â”‚  â”‚ å®¡è®¡ç³»ç»Ÿ    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. åŒæ„ç®¡ç†ç³»ç»Ÿ
```typescript
class ConsentManager {
  private consentStore = new ConsentStore();
  
  async recordConsent(userId: string, consentType: ConsentType, details: ConsentDetails) {
    const consent: UserConsent = {
      id: generateId(),
      userId,
      type: consentType,
      version: '1.0',
      grantedAt: new Date(),
      expiresAt: this.calculateExpiry(consentType),
      details,
      status: 'active',
      ipAddress: this.getClientIP(),
      userAgent: this.getUserAgent()
    };
    
    await this.consentStore.save(consent);
    return consent;
  }
  
  async checkConsent(userId: string, consentType: ConsentType): Promise<boolean> {
    const consent = await this.consentStore.findActiveConsent(userId, consentType);
    return consent !== null && consent.status === 'active';
  }
  
  async revokeConsent(userId: string, consentType: ConsentType) {
    const consent = await this.consentStore.findActiveConsent(userId, consentType);
    if (consent) {
      consent.status = 'revoked';
      consent.revokedAt = new Date();
      await this.consentStore.update(consent);
      
      // è§¦å‘æ•°æ®åˆ é™¤æµç¨‹
      await this.initiateDataDeletion(userId, consentType);
    }
  }
}
```

### 2. æ•°æ®åŠ å¯†ç³»ç»Ÿ
```typescript
class DataEncryption {
  private keyManager = new KeyManager();
  
  async encryptSensitiveData(data: any, userId: string): Promise<EncryptedData> {
    const key = await this.keyManager.getUserKey(userId);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([
      cipher.update(JSON.stringify(data)),
      cipher.final()
    ]);
    
    const authTag = cipher.getAuthTag();
    
    return {
      data: encrypted.toString('base64'),
      iv: iv.toString('base64'),
      authTag: authTag.toString('base64'),
      algorithm: 'aes-256-gcm',
      keyVersion: key.version
    };
  }
  
  async decryptSensitiveData(encrypted: EncryptedData, userId: string): Promise<any> {
    const key = await this.keyManager.getUserKey(userId);
    const iv = Buffer.from(encrypted.iv, 'base64');
    const authTag = Buffer.from(encrypted.authTag, 'base64');
    const data = Buffer.from(encrypted.data, 'base64');
    
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(authTag);
    
    const decrypted = Buffer.concat([
      decipher.update(data),
      decipher.final()
    ]);
    
    return JSON.parse(decrypted.toString());
  }
}
```

### 3. å·®åˆ†éšç§ç³»ç»Ÿ
```typescript
class DifferentialPrivacy {
  private privacyBudget = new PrivacyBudgetManager();
  
  async addNoise(data: number[], sensitivity: number, epsilon: number): Promise<number[]> {
    const scale = sensitivity / epsilon;
    const noisyData = data.map(value => {
      const noise = this.laplaceNoise(0, scale);
      return value + noise;
    });
    
    // è®°å½•éšç§é¢„ç®—ä½¿ç”¨
    await this.privacyBudget.consume(epsilon);
    
    return noisyData;
  }
  
  private laplaceNoise(mu: number, b: number): number {
    const u = Math.random() - 0.5;
    return mu - b * Math.sign(u) * Math.log(1 - 2 * Math.abs(u));
  }
  
  async localDifferentialPrivacy(data: any, epsilon: number): Promise<any> {
    // å¯¹äºåˆ†ç±»æ•°æ®ï¼Œä½¿ç”¨éšæœºå“åº”
    if (typeof data === 'string') {
      return this.randomizedResponse(data, epsilon);
    }
    
    // å¯¹äºæ•°å€¼æ•°æ®ï¼Œæ·»åŠ æ‹‰æ™®æ‹‰æ–¯å™ªå£°
    if (typeof data === 'number') {
      const noise = this.laplaceNoise(0, 1 / epsilon);
      return data + noise;
    }
    
    // å¯¹äºå¤æ‚æ•°æ®ï¼Œé€’å½’å¤„ç†
    if (typeof data === 'object') {
      const result = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = await this.localDifferentialPrivacy(value, epsilon);
      }
      return result;
    }
    
    return data;
  }
  
  private randomizedResponse(value: string, epsilon: number): string {
    const p = Math.exp(epsilon) / (Math.exp(epsilon) + 1);
    if (Math.random() < p) {
      return value;
    } else {
      // éšæœºé€‰æ‹©å…¶ä»–å¯èƒ½çš„å€¼
      const possibleValues = this.getPossibleValues(value);
      return possibleValues[Math.floor(Math.random() * possibleValues.length)];
    }
  }
}
```

### 4. è®¿é—®æ§åˆ¶ç³»ç»Ÿ
```typescript
class AccessControl {
  private policyStore = new PolicyStore();
  
  async canAccess(userId: string, resource: string, action: string): Promise<boolean> {
    // æ£€æŸ¥ç”¨æˆ·æƒé™
    const userPermissions = await this.getUserPermissions(userId);
    
    // æ£€æŸ¥èµ„æºæƒé™
    const resourcePolicy = await this.policyStore.getResourcePolicy(resource);
    
    // æ£€æŸ¥åŠ¨ä½œæƒé™
    const actionPolicy = await this.policyStore.getActionPolicy(action);
    
    // è¯„ä¼°æƒé™
    return this.evaluateAccess(userPermissions, resourcePolicy, actionPolicy);
  }
  
  async logAccess(userId: string, resource: string, action: string, granted: boolean) {
    const accessLog: AccessLog = {
      id: generateId(),
      userId,
      resource,
      action,
      granted,
      timestamp: new Date(),
      ipAddress: this.getClientIP(),
      userAgent: this.getUserAgent(),
      context: this.getRequestContext()
    };
    
    await this.auditLogger.log(accessLog);
  }
  
  private evaluateAccess(userPermissions: Permission[], resourcePolicy: Policy, actionPolicy: Policy): boolean {
    // åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
    if (!this.hasRequiredRole(userPermissions, resourcePolicy.requiredRoles)) {
      return false;
    }
    
    // åŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶
    if (!this.satisfiesAttributes(userPermissions, resourcePolicy.requiredAttributes)) {
      return false;
    }
    
    // åŸºäºæ—¶é—´çš„è®¿é—®æ§åˆ¶
    if (!this.isWithinTimeWindow(resourcePolicy.timeRestrictions)) {
      return false;
    }
    
    return true;
  }
}
```

### 5. æ•°æ®åˆ é™¤ç³»ç»Ÿ
```typescript
class DataDeletion {
  private deletionQueue = new DeletionQueue();
  
  async scheduleDataDeletion(userId: string, dataType: string, reason: DeletionReason) {
    const deletionRequest: DeletionRequest = {
      id: generateId(),
      userId,
      dataType,
      reason,
      status: 'pending',
      scheduledAt: new Date(),
      estimatedCompletion: this.calculateEstimatedCompletion(dataType)
    };
    
    await this.deletionQueue.add(deletionRequest);
    return deletionRequest;
  }
  
  async executeDataDeletion(request: DeletionRequest) {
    try {
      request.status = 'processing';
      await this.deletionQueue.update(request);
      
      // åˆ é™¤ä¸»æ•°æ®
      await this.deletePrimaryData(request.userId, request.dataType);
      
      // åˆ é™¤å¤‡ä»½æ•°æ®
      await this.deleteBackupData(request.userId, request.dataType);
      
      // åˆ é™¤ç¼“å­˜æ•°æ®
      await this.deleteCacheData(request.userId, request.dataType);
      
      // åˆ é™¤æ—¥å¿—æ•°æ®ï¼ˆä¿ç•™å®¡è®¡æ—¥å¿—ï¼‰
      await this.deleteLogData(request.userId, request.dataType);
      
      request.status = 'completed';
      request.completedAt = new Date();
      
      await this.deletionQueue.update(request);
      await this.notifyUser(request.userId, request);
      
    } catch (error) {
      request.status = 'failed';
      request.error = error.message;
      await this.deletionQueue.update(request);
      await this.notifyAdmin(request, error);
    }
  }
}
```

---

## ğŸ“Š æ•°æ®åˆ†ç±»ä¸å¤„ç†

### æ•°æ®åˆ†ç±»
```typescript
enum DataClassification {
  PUBLIC = 'public',           // å…¬å¼€æ•°æ®
  INTERNAL = 'internal',       // å†…éƒ¨æ•°æ®
  CONFIDENTIAL = 'confidential', // æœºå¯†æ•°æ®
  RESTRICTED = 'restricted',    // é™åˆ¶æ•°æ®
  HIGHLY_RESTRICTED = 'highly_restricted' // é«˜åº¦é™åˆ¶æ•°æ®
}

const dataClassificationRules = {
  // ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
  'user.name': DataClassification.CONFIDENTIAL,
  'user.email': DataClassification.CONFIDENTIAL,
  'user.phone': DataClassification.RESTRICTED,
  'user.address': DataClassification.RESTRICTED,
  
  // ç”¨æˆ·è¡Œä¸ºæ•°æ®
  'user.behavior': DataClassification.INTERNAL,
  'user.preferences': DataClassification.CONFIDENTIAL,
  'user.interactions': DataClassification.INTERNAL,
  
  // æ•æ„Ÿæ•°æ®
  'user.health': DataClassification.HIGHLY_RESTRICTED,
  'user.financial': DataClassification.HIGHLY_RESTRICTED,
  'user.biometric': DataClassification.HIGHLY_RESTRICTED
};
```

### æ•°æ®å¤„ç†ç­–ç•¥
```typescript
class DataProcessingStrategy {
  getStrategy(dataType: string): ProcessingStrategy {
    const classification = this.getDataClassification(dataType);
    
    switch (classification) {
      case DataClassification.PUBLIC:
        return {
          encryption: false,
          anonymization: false,
          retention: 'permanent',
          sharing: 'allowed'
        };
        
      case DataClassification.INTERNAL:
        return {
          encryption: true,
          anonymization: false,
          retention: '1y',
          sharing: 'internal'
        };
        
      case DataClassification.CONFIDENTIAL:
        return {
          encryption: true,
          anonymization: true,
          retention: '90d',
          sharing: 'restricted'
        };
        
      case DataClassification.RESTRICTED:
        return {
          encryption: true,
          anonymization: true,
          retention: '30d',
          sharing: 'none'
        };
        
      case DataClassification.HIGHLY_RESTRICTED:
        return {
          encryption: true,
          anonymization: true,
          retention: '7d',
          sharing: 'none',
          localOnly: true
        };
        
      default:
        throw new Error(`Unknown data classification: ${classification}`);
    }
  }
}
```

---

## ğŸ›¡ï¸ å®‰å…¨æªæ–½

### ç½‘ç»œå®‰å…¨
```typescript
class NetworkSecurity {
  private rateLimiter = new RateLimiter();
  private firewall = new Firewall();
  
  async secureConnection(request: Request) {
    // æ£€æŸ¥HTTPS
    if (!request.secure) {
      throw new Error('HTTPS required');
    }
    
    // æ£€æŸ¥è¯·æ±‚å¤´
    this.validateHeaders(request.headers);
    
    // æ£€æŸ¥é€Ÿç‡é™åˆ¶
    await this.rateLimiter.check(request.ip);
    
    // æ£€æŸ¥é˜²ç«å¢™è§„åˆ™
    await this.firewall.check(request);
    
    return request;
  }
}
```

### åº”ç”¨å®‰å…¨
```typescript
class ApplicationSecurity {
  private inputValidator = new InputValidator();
  private xssProtection = new XSSProtection();
  private csrfProtection = new CSRFProtection();
  
  async secureRequest(request: Request) {
    // è¾“å…¥éªŒè¯
    const sanitizedInput = await this.inputValidator.validate(request.body);
    
    // XSSé˜²æŠ¤
    const sanitizedOutput = this.xssProtection.sanitize(sanitizedInput);
    
    // CSRFé˜²æŠ¤
    await this.csrfProtection.validate(request);
    
    return sanitizedOutput;
  }
}
```

---

## ğŸ“ˆ ç›‘æ§ä¸å®¡è®¡

### éšç§ç›‘æ§
```typescript
class PrivacyMonitor {
  private metrics = new MetricsCollector();
  
  async monitorDataAccess(userId: string, dataType: string, accessedBy: string) {
    // è®°å½•è®¿é—®æŒ‡æ ‡
    await this.metrics.increment('data_access_count', {
      userId,
      dataType,
      accessedBy
    });
    
    // æ£€æŸ¥å¼‚å¸¸è®¿é—®æ¨¡å¼
    await this.detectAnomalies(userId, accessedBy);
    
    // æ£€æŸ¥æƒé™æ»¥ç”¨
    await this.detectPermissionAbuse(accessedBy, dataType);
  }
  
  async detectAnomalies(userId: string, accessedBy: string) {
    const accessPattern = await this.getAccessPattern(userId);
    
    // æ£€æŸ¥å¼‚å¸¸æ—¶é—´è®¿é—®
    if (this.isUnusualTime(accessPattern.lastAccess)) {
      await this.alertSecurityTeam('unusual_time_access', { userId, accessedBy });
    }
    
    // æ£€æŸ¥å¼‚å¸¸é¢‘ç‡è®¿é—®
    if (this.isUnusualFrequency(accessPattern.frequency)) {
      await this.alertSecurityTeam('unusual_frequency_access', { userId, accessedBy });
    }
  }
}
```

### å®¡è®¡æ—¥å¿—
```typescript
class AuditLogger {
  async logPrivacyEvent(event: PrivacyEvent) {
    const auditLog: AuditLog = {
      id: generateId(),
      timestamp: new Date(),
      eventType: event.type,
      userId: event.userId,
      resource: event.resource,
      action: event.action,
      result: event.result,
      details: event.details,
      ipAddress: event.ipAddress,
      userAgent: event.userAgent,
      sessionId: event.sessionId
    };
    
    // ä¿å­˜åˆ°å®‰å…¨å­˜å‚¨
    await this.secureStorage.save(auditLog);
    
    // å®æ—¶ç›‘æ§
    await this.realTimeMonitor.process(auditLog);
    
    // å¼‚æ­¥åˆ†æ
    await this.analyticsQueue.add(auditLog);
  }
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### éšç§æµ‹è¯•
```typescript
describe('PrivacySystem', () => {
  it('should protect sensitive data', async () => {
    const sensitiveData = { email: 'user@example.com', phone: '123-456-7890' };
    const encrypted = await privacySystem.encrypt(sensitiveData);
    
    expect(encrypted.data).not.toContain('user@example.com');
    expect(encrypted.data).not.toContain('123-456-7890');
    
    const decrypted = await privacySystem.decrypt(encrypted);
    expect(decrypted).toEqual(sensitiveData);
  });
  
  it('should enforce access control', async () => {
    const result = await accessControl.canAccess('user1', 'profile', 'read');
    expect(result).toBe(true);
    
    const unauthorizedResult = await accessControl.canAccess('user2', 'profile', 'read');
    expect(unauthorizedResult).toBe(false);
  });
  
  it('should handle data deletion', async () => {
    await deletionSystem.scheduleDataDeletion('user1', 'profile', 'user_request');
    
    const deletionRequest = await deletionQueue.get('user1', 'profile');
    expect(deletionRequest.status).toBe('pending');
    
    await deletionSystem.executeDataDeletion(deletionRequest);
    
    const profile = await profileStore.get('user1');
    expect(profile).toBeNull();
  });
});
```

---

## ğŸ“Š åˆè§„æ€§æ£€æŸ¥

### GDPRåˆè§„
```typescript
class GDPRCompliance {
  async checkCompliance(): Promise<ComplianceReport> {
    const checks = [
      await this.checkLawfulBasis(),
      await this.checkDataMinimization(),
      await this.checkPurposeLimitation(),
      await this.checkAccuracy(),
      await this.checkStorageLimitation(),
      await this.checkIntegrityConfidentiality(),
      await this.checkTransparency()
    ];
    
    return {
      overall: checks.every(check => check.passed),
      checks,
      timestamp: new Date()
    };
  }
  
  async checkLawfulBasis(): Promise<ComplianceCheck> {
    const usersWithoutConsent = await this.findUsersWithoutConsent();
    const passed = usersWithoutConsent.length === 0;
    
    return {
      name: 'Lawful Basis',
      passed,
      details: passed ? 'All users have lawful basis' : `Found ${usersWithoutConsent.length} users without lawful basis`,
      recommendations: passed ? [] : ['Obtain consent from users without lawful basis']
    };
  }
}
```

---

**æ–‡æ¡£ç»“æŸ**

æœ¬è®¾è®¡æ–‡æ¡£ä¸ºChat4éšç§ä¿æŠ¤ç³»ç»Ÿæä¾›äº†å…¨é¢çš„æŠ€æœ¯å®ç°æ–¹æ¡ˆï¼Œç¡®ä¿ç³»ç»Ÿç¬¦åˆéšç§ä¿æŠ¤çš„æœ€ä½³å®è·µå’Œæ³•è§„è¦æ±‚ã€‚